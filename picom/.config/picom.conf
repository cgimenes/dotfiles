shadow = true;
shadow-radius = 7;
shadow-offset-x = -7;
shadow-offset-y = -7;

fading = true;
fade-delta = 5

blur-kern = "3x3box";

backend = "xrender"
vsync = true;

# Detect '_NET_WM_WINDOW_OPACITY' on client windows, useful for window managers
# not passing '_NET_WM_WINDOW_OPACITY' of client windows to frame windows.
detect-client-opacity = true;
# Use 'WM_TRANSIENT_FOR' to group windows, and consider windows
# in the same group focused at the same time.
detect-transient = true;
# Use of damage information for rendering. This cause the only the part of the
# screen that has actually changed to be redrawn, instead of the whole screen
# every time. Should improve performance.
use-damage = true;

rules: ({
  match = "window_type = 'tooltip'";
  fade = false;
  shadow = true;
  opacity = 0.75;
  full-shadow = false;
}, {
  match = "window_type = 'dock'    || "
          "window_type = 'desktop' || "
          "_GTK_FRAME_EXTENTS@";
  blur-background = false;
}, {
  match = "window_type != 'dock'";
}, {
  match = "window_type = 'dock' || "
          "window_type = 'desktop'";
  corner-radius = 0;
}, {
  match = "name = 'Notification'   || "
          "class_g = 'Conky'       || "
          "class_g ?= 'Notify-osd' || "
          "class_g = 'Cairo-clock' || "
          "_GTK_FRAME_EXTENTS@";
  shadow = false;
},
# Animations for NORMAL windows.
{
  match = "window_type = 'normal'";
  animations = (
      {
      triggers = ["close", "hide"];
      opacity = {
      curve = "linear";
      duration = 0.1;
      start = "window-raw-opacity-before";
      end = 0;
      };
      blur-opacity = "opacity";
      shadow-opacity = "opacity";
      },
      {
      triggers = ["open", "show"];
      opacity = {
      curve = "cubic-bezier(0,1,1,1)";
      duration = 0.5;
      start = 0;
      end = "window-raw-opacity";
      };
      blur-opacity = "opacity";
      shadow-opacity = "opacity";
      offset-x = "(1 - scale-x) / 2 * window-width";
      offset-y = "(1 - scale-y) / 2 * window-height";
      scale-x = {
        curve = "cubic-bezier(0,1.3,1,1)";
        duration = 0.5;
        start = 0.6;
        end = 1;
      };
      scale-y = "scale-x";
      shadow-scale-x = "scale-x";
      shadow-scale-y = "scale-y";
      shadow-offset-x = "offset-x";
      shadow-offset-y = "offset-y";
      },
      {
        triggers = ["geometry"]
          scale-x = {
            curve = "cubic-bezier(0,0,0,1.28)";
            duration = 0.5;
            start = "window-width-before / window-width";
            end = 1;
          }
        scale-y = {
          curve = "cubic-bezier(0,0,0,1.28)";
          duration = 0.5;
          start = "window-height-before / window-height";
          end = 1;
        }
        offset-x = {
          curve = "cubic-bezier(0,0,0,1.28)";
          duration = 0.5;
          start = "window-x-before - window-x";
          end = 0;
        }
        offset-y = {
          curve = "cubic-bezier(0,0,0,1.28)";
          duration = 0.5;
          start = "window-y-before - window-y";
          end = 0;
        }
        shadow-scale-x = "scale-x";
        shadow-scale-y = "scale-y";
        shadow-offset-x = "offset-x";
        shadow-offset-y = "offset-y";
      }
  )
},
# Animations for Rofi launchers.
{
  match = "class_g = 'Rofi'";
  animations = (
      {
      triggers = ["close", "hide"];
      preset = "disappear";
      duration = 0.05;
      scale = 0.5;
      },
      {
      triggers = ["open", "show"];
      preset = "appear";
      duration = 0.2;
      scale = 0.5;
      }
      )
},
# Animations for Dunst notifications.
{
  match = "class_g = 'Dunst'";
  animations = (
      {
      triggers = ["close", "hide"];
      preset = "fly-out";     #-dunst-close-preset
      direction = "up";       #-dunst-close-direction
      duration = 0.2;
      },
      {
      triggers = ["open", "show"];
      preset = "fly-in";      #-dunst-open-preset
      direction = "up";       #-dunst-open-direction
      duration = 0.2;
      }
      )
}
)
